---
/**
 * `text`: the text to render. Will be split in to an array of strings.
 * `classes`: an array of strings. [0] for the first line, [n] for the last.
 * `options`: TBC.
 */
interface Props {
  text: string;
  classArray?: Array<string>;
  options?: any;
}
import type { JDLine } from "./jdBlockFunctions";

const { text, classArray = [], options } = Astro.props;

/**
 * Split `text` in to an array of strings. Each is a line for further
 * processing.
 */
import { textToArrayOfStrings } from "./jdBlockFunctions";
const textAsArrayOfStrings = textToArrayOfStrings(text);
console.log("textAsArrayOfStrings :", textAsArrayOfStrings);

// ...do more processing, but end up at the same place...

/**
 * We have `textAsArrayOfStrings`, and `classArray` which is already
 * an array of class strings. Construct the `arrayToRender`.
 */

import { constructArrayToRender } from "./jdBlockFunctions";
const arrayToRender = constructArrayToRender(textAsArrayOfStrings, classArray);
---

<div>== JDBlock starts</div>
{
  arrayToRender.map((line) => {
    return <pre class:list={line.classes}>{line.text}</pre>;
  })
}
<div>== JDBlock ends</div>

<style lang="scss">
  @use "/src/styles/johnny" as *;

  pre {
    font-family: $monospace;

    &.test-class {
      color: hotpink;
    }
    &.another-class {
      background: yellow;
    }
  }
</style>
